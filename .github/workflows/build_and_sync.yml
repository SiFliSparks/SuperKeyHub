name: Build and Release

on:
  push:
    tags:
      - "v*"
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      skip_sync:
        description: "Skip COS sync (for testing builds only)"
        required: false
        default: "false"
        type: boolean
      force_release:
        description: "Force create release (ignore commit message check)"
        required: false
        default: "false"
        type: boolean

env:
  APP_NAME: SuperKeyHUB
  PYTHON_VERSION: "3.11"
  UV_VERSION: "0.5.14"

jobs:
  # ============================================================================
  # 检测是否需要创建 release
  # ============================================================================
  check-release:
    name: Check Release Trigger
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      app_version: ${{ steps.check.outputs.app_version }}
      is_tag: ${{ steps.check.outputs.is_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check release conditions
        id: check
        run: |
          # 检查是否是 tag 触发
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "[TAG] Triggered by tag: ${{ github.ref_name }}"
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "is_tag=true" >> $GITHUB_OUTPUT
            # 从 tag 名称提取版本号（去掉 v 前缀）
            TAG_VERSION="${{ github.ref_name }}"
            echo "app_version=${TAG_VERSION#v}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "is_tag=false" >> $GITHUB_OUTPUT
          
          # 检查是否手动触发并强制发布
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.force_release }}" == "true" ]]; then
            echo "[BUILD] Force release triggered manually"
            FORCE_RELEASE=true
          else
            FORCE_RELEASE=false
          fi
          
          # 检查 commit message 是否包含 release（不区分大小写）
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "[MSG] Commit message: $COMMIT_MSG"
          
          if echo "$COMMIT_MSG" | grep -iq "release" || [[ "$FORCE_RELEASE" == "true" ]]; then
            echo "[OK] Release keyword found or force release enabled"
            
            # 从 main.py 提取 APP_VERSION
            APP_VERSION=$(grep -oP 'APP_VERSION:\s*str\s*=\s*"\K[^"]+' main.py)
            
            if [[ -z "$APP_VERSION" ]]; then
              echo "[FAIL] Could not extract APP_VERSION from main.py"
              exit 1
            fi
            
            echo "[PKG] Detected APP_VERSION: $APP_VERSION"
            
            # 检查该版本的 tag 是否已存在
            if git rev-parse "v$APP_VERSION" >/dev/null 2>&1; then
              echo "[WARN] Tag v$APP_VERSION already exists, skipping release"
              echo "should_release=false" >> $GITHUB_OUTPUT
            else
              echo "[OK] Tag v$APP_VERSION does not exist, will create release"
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
            fi
          else
            echo "[INFO] No release keyword in commit message, skipping release"
            echo "should_release=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Windows 构建
  # ============================================================================
  build-windows:
    name: Build Windows
    needs: check-release
    runs-on: windows-latest
    outputs:
      app_version: ${{ steps.version.outputs.app_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: ${{ env.UV_VERSION }}

      - name: Install dependencies
        shell: pwsh
        run: |
          Write-Host "[STEP 1] Installing base dependencies with windows extras..."
          uv sync --extra windows
          
          Write-Host "[STEP 2] Installing dev dependencies..."
          uv sync --group dev
          
          Write-Host "[STEP 3] Verifying PyInstaller installation..."
          $result = uv run python -c "import PyInstaller; print('OK')" 2>&1
          if ($LASTEXITCODE -ne 0) {
              Write-Host "[WARN] PyInstaller not found via uv sync, installing via pip..."
              uv pip install pyinstaller
          }
          
          uv run pyinstaller --version
          if ($LASTEXITCODE -ne 0) {
              Write-Error "[FAIL] PyInstaller installation failed"
              exit 1
          }
          Write-Host "[OK] PyInstaller installed successfully"

      - name: Verify required assets
        shell: pwsh
        run: |
          Write-Host "[CHECK] Verifying required assets..."
          
          # 检查图标文件
          if (Test-Path "assets\app.ico") {
              Write-Host "[OK] app.ico found"
              Get-Item "assets\app.ico" | Select-Object Name, Length
          } else {
              Write-Error "[FAIL] assets\app.ico not found - required for Windows build"
              Write-Host "Please ensure app.ico is committed to the assets/ directory"
              exit 1
          }
          
          # 检查 LICENSE 文件（NSIS 需要）
          if (Test-Path "LICENSE") {
              Write-Host "[OK] LICENSE file found"
          } else {
              Write-Warning "[WARN] LICENSE file not found - NSIS installer may fail"
          }

      - name: Verify sftool in tools directory
        shell: pwsh
        run: |
          if (Test-Path "tools\sftool.exe") {
              Write-Host "[OK] sftool.exe found in tools directory"
              Get-Item "tools\sftool.exe" | Select-Object Name, Length
          } else {
              Write-Warning "[WARN] sftool.exe not found in tools directory"
              Write-Host "Firmware update functionality will not be available"
          }

      - name: Check Python dependencies
        shell: pwsh
        run: |
          Write-Host "[CHECK] Verifying critical dependencies..."
          
          uv run python -c "import PyInstaller; print('PyInstaller:', PyInstaller.__version__)"
          uv run python -c "import clr; print('pythonnet: OK')"
          uv run python -c "import wmi; print('wmi: OK')"
          uv run python -c "import flet; print('flet: OK')"
          
          Write-Host "[OK] All critical dependencies available"

      - name: Run lint check
        shell: pwsh
        env:
          PYTHONIOENCODING: utf-8
        run: |
          uv run ruff check . --select=E,F
        continue-on-error: true

      - name: Extract version and create version JSON
        id: version
        shell: pwsh
        run: |
          # 从 main.py 提取 APP_VERSION
          $versionMatch = Select-String -Path "main.py" -Pattern 'APP_VERSION:\s*str\s*=\s*"([^"]+)"'
          if ($versionMatch) {
              $appVersion = $versionMatch.Matches.Groups[1].Value
              Write-Host "[OK] Detected APP_VERSION: $appVersion"
          } else {
              Write-Error "[FAIL] Could not find APP_VERSION in main.py"
              exit 1
          }
          
          # 从 main.py 提取 FIRMWARE_COMPAT（可选）
          $firmwareMatch = Select-String -Path "main.py" -Pattern 'FIRMWARE_COMPAT:\s*str\s*=\s*"([^"]+)"'
          $firmwareCompat = ""
          if ($firmwareMatch) {
              $firmwareCompat = $firmwareMatch.Matches.Groups[1].Value
              Write-Host "[OK] Detected FIRMWARE_COMPAT: $firmwareCompat"
          }
          
          # 获取当前时间戳
          $buildTime = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
          
          # 创建版本 JSON 文件
          $versionInfo = @{
              version = $appVersion
              firmware_compat = $firmwareCompat
              build_time = $buildTime
          }
          
          $jsonContent = $versionInfo | ConvertTo-Json -Depth 10
          $jsonContent | Out-File -FilePath "hub_verid.json" -Encoding UTF8
          
          Write-Host "[OK] Created hub_verid.json:"
          Get-Content "hub_verid.json"
          
          echo "app_version=$appVersion" >> $env:GITHUB_OUTPUT

      - name: Build with PyInstaller
        shell: pwsh
        env:
          PYTHONIOENCODING: utf-8
          PYTHONUNBUFFERED: "1"
        run: |
          Write-Host "[DEBUG] Python version:"
          uv run python --version
          Write-Host "[DEBUG] PyInstaller version:"
          uv run python -c "import PyInstaller; print(PyInstaller.__version__)"
          
          # 运行构建
          uv run python build.py --no-installer --skip-deps
          
          if ($LASTEXITCODE -ne 0) {
              Write-Host "[DEBUG] Build failed, checking for logs..."
              if (Test-Path "build\SuperKeyHUB\warn-SuperKeyHUB.txt") {
                  Write-Host "[DEBUG] PyInstaller warnings:"
                  Get-Content "build\SuperKeyHUB\warn-SuperKeyHUB.txt"
              }
              exit $LASTEXITCODE
          }

      - name: Verify build output
        shell: pwsh
        run: |
          if (Test-Path "dist\${{ env.APP_NAME }}\${{ env.APP_NAME }}.exe") {
              Write-Host "[OK] Build successful"
              Get-ChildItem "dist\${{ env.APP_NAME }}" | Select-Object Name, Length
          } else {
              Write-Error "[FAIL] Build failed - exe not found"
              exit 1
          }
          
          # 验证 libs 目录
          if (Test-Path "dist\${{ env.APP_NAME }}\libs") {
              Write-Host "[OK] libs directory included"
              Get-ChildItem "dist\${{ env.APP_NAME }}\libs" | Select-Object Name, Length
          } else {
              Write-Warning "[WARN] libs directory not found in build output"
          }
          
          # 验证 assets 目录
          if (Test-Path "dist\${{ env.APP_NAME }}\assets") {
              Write-Host "[OK] assets directory included"
          } else {
              Write-Warning "[WARN] assets directory not found in build output"
          }
          
          # 验证 tools 目录
          if (Test-Path "dist\${{ env.APP_NAME }}\tools") {
              Write-Host "[OK] tools directory included"
              Get-ChildItem "dist\${{ env.APP_NAME }}\tools" | Select-Object Name, Length
          }

      - name: Install NSIS
        run: |
          choco install nsis -y

      - name: Build NSIS Installer
        shell: pwsh
        run: |
          # 验证 NSIS 脚本存在
          if (-not (Test-Path "installer.nsi")) {
              Write-Error "[FAIL] installer.nsi not found"
              exit 1
          }
          
          # 更新 NSIS 脚本中的版本号
          $version = "${{ steps.version.outputs.app_version }}"
          Write-Host "[INFO] Building installer for version: $version"
          
          & "C:\Program Files (x86)\NSIS\makensis.exe" installer.nsi
          
          if ($LASTEXITCODE -ne 0) {
              Write-Error "[FAIL] NSIS build failed"
              exit 1
          }

      - name: Verify installer
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.app_version }}"
          $installerPath = "dist\${{ env.APP_NAME }}-${version}-Setup.exe"
          
          if (Test-Path $installerPath) {
              Write-Host "[OK] Installer created: $installerPath"
              Get-Item $installerPath | Select-Object Name, Length
          } else {
              Write-Warning "[WARN] Installer not found at expected path"
              Write-Host "Looking for installers in dist:"
              Get-ChildItem "dist" -Filter "*.exe"
          }

      - name: Create portable ZIP
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.app_version }}"
          $zipName = "${{ env.APP_NAME }}-${version}-Windows-Portable.zip"
          
          Compress-Archive -Path "dist\${{ env.APP_NAME }}\*" -DestinationPath "dist\$zipName"
          Write-Host "[OK] Portable ZIP created: dist\$zipName"

      - name: Copy version JSON to dist
        shell: pwsh
        run: |
          Copy-Item "hub_verid.json" -Destination "dist\" -Force
          Write-Host "[OK] hub_verid.json copied to dist folder"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v5
        with:
          name: windows-build
          path: |
            dist/*.exe
            dist/*.zip
            dist/hub_verid.json
          retention-days: 7

  # ============================================================================
  # macOS 构建 (Universal - Intel + Apple Silicon)
  # ============================================================================
  build-macos:
    name: Build macOS
    needs: check-release
    runs-on: macos-14  # Apple Silicon runner
    outputs:
      app_version: ${{ steps.version.outputs.app_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: ${{ env.UV_VERSION }}

      - name: Install dependencies
        run: |
          echo "[STEP 1] Installing base dependencies..."
          uv sync
          
          echo "[STEP 2] Installing dev dependencies..."
          uv sync --group dev
          
          echo "[STEP 3] Verifying PyInstaller installation..."
          uv run pyinstaller --version || {
              echo "[WARN] PyInstaller not found, installing via pip..."
              uv pip install pyinstaller
          }
          
          echo "[OK] PyInstaller installed successfully"

      - name: Verify required assets
        run: |
          echo "[CHECK] Verifying required assets..."
          
          # 检查 macOS 图标
          if [ -f "assets/app.icns" ]; then
              echo "[OK] app.icns found"
              ls -la assets/app.icns
          else
              echo "[WARN] assets/app.icns not found"
              echo "Will proceed without custom icon"
          fi
          
          # 检查 LICENSE 文件
          if [ -f "LICENSE" ]; then
              echo "[OK] LICENSE file found"
          fi

      - name: Verify tools directory
        run: |
          echo "[CHECK] Checking tools directory..."
          
          # sftool for macOS
          if [ -f "tools/sftool" ]; then
              echo "[OK] sftool found"
              chmod +x tools/sftool
              ls -la tools/sftool
          else
              echo "[WARN] tools/sftool not found - firmware update will not work"
          fi
          
          # macmon (optional, for Apple Silicon metrics)
          if [ -f "tools/macmon" ]; then
              echo "[OK] macmon found"
              chmod +x tools/macmon
          else
              echo "[INFO] macmon not bundled - will try system version at runtime"
          fi

      - name: Check for native library source
        run: |
          if [ -d "macos_native" ]; then
              echo "[OK] macos_native directory found"
              ls -la macos_native/
          else
              echo "[INFO] No macos_native directory - using psutil fallback"
          fi

      - name: Build native library (if exists)
        run: |
          if [ -d "macos_native" ] && [ -f "macos_native/Makefile" ]; then
              echo "[BUILD] Compiling native macOS sensor library..."
              cd macos_native
              make clean || true
              make
              
              if [ -f "libmacos_sensors.dylib" ]; then
                  echo "[OK] Native library built successfully"
                  mkdir -p ../libs
                  cp libmacos_sensors.dylib ../libs/
              fi
              cd ..
          fi

      - name: Run lint check
        env:
          PYTHONIOENCODING: utf-8
        run: |
          uv run ruff check . --select=E,F || true

      - name: Extract version
        id: version
        run: |
          # 从 main.py 提取 APP_VERSION
          APP_VERSION=$(grep -oE 'APP_VERSION:\s*str\s*=\s*"[^"]+"' main.py | sed 's/.*"\(.*\)"/\1/')
          
          if [ -z "$APP_VERSION" ]; then
              echo "[FAIL] Could not find APP_VERSION in main.py"
              exit 1
          fi
          
          echo "[OK] Detected APP_VERSION: $APP_VERSION"
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          
          # 提取 FIRMWARE_COMPAT（可选）
          FIRMWARE_COMPAT=$(grep -oE 'FIRMWARE_COMPAT:\s*str\s*=\s*"[^"]+"' main.py | sed 's/.*"\(.*\)"/\1/' || echo "")
          
          # 创建版本 JSON
          cat > hub_verid.json << EOF
          {
            "version": "$APP_VERSION",
            "firmware_compat": "$FIRMWARE_COMPAT",
            "build_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          }
          EOF
          
          echo "[OK] Created hub_verid.json"
          cat hub_verid.json

      - name: Build with PyInstaller
        env:
          PYTHONIOENCODING: utf-8
          PYTHONUNBUFFERED: "1"
        run: |
          echo "[DEBUG] Python version:"
          uv run python --version
          echo "[DEBUG] PyInstaller version:"
          uv run python -c "import PyInstaller; print(PyInstaller.__version__)"
          
          # 运行构建（跳过 DMG，后面单独处理）
          uv run python build.py --no-installer --skip-deps
          
          if [ $? -ne 0 ]; then
              echo "[FAIL] Build failed"
              if [ -f "build/SuperKeyHUB/warn-SuperKeyHUB.txt" ]; then
                  echo "[DEBUG] PyInstaller warnings:"
                  cat "build/SuperKeyHUB/warn-SuperKeyHUB.txt"
              fi
              exit 1
          fi

      - name: Verify and prepare .app bundle
        run: |
          APP_PATH="dist/${{ env.APP_NAME }}.app"
          PYINSTALLER_APP="dist/${{ env.APP_NAME }}/${{ env.APP_NAME }}.app"
          
          # PyInstaller 可能将 .app 放在子目录中
          if [ -d "$PYINSTALLER_APP" ] && [ ! -d "$APP_PATH" ]; then
              echo "[INFO] Moving .app from subdirectory..."
              mv "$PYINSTALLER_APP" "$APP_PATH"
          fi
          
          if [ -d "$APP_PATH" ]; then
              echo "[OK] App bundle found: $APP_PATH"
              ls -la "$APP_PATH"
              
              # 设置工具执行权限
              TOOLS_PATH="$APP_PATH/Contents/Resources/tools"
              if [ -d "$TOOLS_PATH" ]; then
                  echo "[INFO] Setting tool permissions..."
                  chmod +x "$TOOLS_PATH"/* 2>/dev/null || true
                  ls -la "$TOOLS_PATH"
              fi
              
              # 验证可执行文件
              MACOS_PATH="$APP_PATH/Contents/MacOS"
              if [ -d "$MACOS_PATH" ]; then
                  echo "[OK] MacOS directory:"
                  ls -la "$MACOS_PATH"
              fi
          else
              echo "[FAIL] App bundle not found"
              echo "Contents of dist:"
              ls -laR dist/
              exit 1
          fi

      - name: Create DMG
        run: |
          VERSION="${{ steps.version.outputs.app_version }}"
          APP_PATH="dist/${{ env.APP_NAME }}.app"
          DMG_NAME="${{ env.APP_NAME }}-${VERSION}-macOS.dmg"
          DMG_PATH="dist/$DMG_NAME"
          
          if [ ! -d "$APP_PATH" ]; then
              echo "[FAIL] App bundle not found at $APP_PATH"
              exit 1
          fi
          
          echo "[BUILD] Creating DMG: $DMG_NAME"
          
          # 删除旧的 DMG（如果存在）
          rm -f "$DMG_PATH"
          
          # 创建 DMG
          hdiutil create \
              -volname "${{ env.APP_NAME }}" \
              -srcfolder "$APP_PATH" \
              -ov \
              -format UDZO \
              "$DMG_PATH"
          
          if [ -f "$DMG_PATH" ]; then
              echo "[OK] DMG created successfully"
              ls -lh "$DMG_PATH"
          else
              echo "[FAIL] DMG creation failed"
              exit 1
          fi

      - name: Create portable ZIP (alternative to DMG)
        run: |
          VERSION="${{ steps.version.outputs.app_version }}"
          APP_PATH="dist/${{ env.APP_NAME }}.app"
          ZIP_NAME="${{ env.APP_NAME }}-${VERSION}-macOS.zip"
          
          cd dist
          zip -r "$ZIP_NAME" "${{ env.APP_NAME }}.app"
          
          echo "[OK] Portable ZIP created: $ZIP_NAME"
          ls -lh "$ZIP_NAME"

      - name: Copy version JSON to dist
        run: |
          cp hub_verid.json dist/
          echo "[OK] hub_verid.json copied to dist"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            dist/*.dmg
            dist/*.zip
            dist/hub_verid.json
          retention-days: 7

  # ============================================================================
  # 同步到腾讯云 COS
  # ============================================================================
  sync-to-cos:
    name: Sync to Tencent COS
    needs: [check-release, build-windows, build-macos]
    runs-on: ubuntu-latest
    if: |
      needs.check-release.outputs.should_release == 'true' &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_sync != 'true')
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: List artifacts
        run: |
          echo "[PKG] Downloaded artifacts:"
          find artifacts -type f -exec ls -lh {} \;

      - name: Prepare upload directories
        run: |
          # 创建版本目录（不包含 hub_verid.json）
          mkdir -p version_artifacts
          find artifacts -type f ! -name "hub_verid.json" -exec cp {} version_artifacts/ \;
          
          # 创建根目录（只包含 hub_verid.json）
          mkdir -p root_artifacts
          cp artifacts/hub_verid.json root_artifacts/ 2>/dev/null || true
          
          echo "[PKG] Version artifacts:"
          ls -lh version_artifacts/
          
          echo "[PKG] Root artifacts (hub_verid.json):"
          ls -lh root_artifacts/

      - name: Upload version artifacts to COS
        uses: OpenSiFli/SiFliMirrorSync@v1
        with:
          secret_id: ${{ secrets.COS_DOCS_SECRET_ID }}
          secret_key: ${{ secrets.COS_DOCS_SECRET_KEY }}
          region: ${{ secrets.COS_DOCS_REGION }}
          bucket: ${{ secrets.COS_DOCS_BUCKET }}
          prefix: projects/superkey/download/software/v${{ needs.check-release.outputs.app_version }}/
          artifacts: version_artifacts/
          delete_remote: true

      - name: Upload hub_verid.json to COS root
        uses: OpenSiFli/SiFliMirrorSync@v1
        with:
          secret_id: ${{ secrets.COS_DOCS_SECRET_ID }}
          secret_key: ${{ secrets.COS_DOCS_SECRET_KEY }}
          region: ${{ secrets.COS_DOCS_REGION }}
          bucket: ${{ secrets.COS_DOCS_BUCKET }}
          prefix: projects/superkey/download/
          artifacts: root_artifacts/
          delete_remote: false

  # ============================================================================
  # 创建 GitHub Release
  # ============================================================================
  create-release:
    name: Create Tag and GitHub Release
    needs: [check-release, build-windows, build-macos, sync-to-cos]
    runs-on: ubuntu-latest
    if: needs.check-release.outputs.should_release == 'true'
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: List release files
        run: |
          echo "[RELEASE] Files to be released:"
          find artifacts -type f -exec ls -lh {} \;

      - name: Create tag if not exists
        if: needs.check-release.outputs.is_tag != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="v${{ needs.check-release.outputs.app_version }}"
          
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "[WARN] Tag $TAG_NAME already exists"
          else
            echo "[TAG] Creating tag: $TAG_NAME"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
            git push origin "$TAG_NAME"
            echo "[OK] Tag $TAG_NAME created and pushed"
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ needs.check-release.outputs.app_version }}"
          
          cat > release_notes.md << 'EOF'
          ## Downloads
          
          ### Windows
          - **安装程序**: `SuperKeyHUB-VERSION-Setup.exe` (推荐)
          - **便携版**: `SuperKeyHUB-VERSION-Windows-Portable.zip`
          
          ### macOS
          - **DMG 安装包**: `SuperKeyHUB-VERSION-macOS.dmg` (推荐)
          - **ZIP 压缩包**: `SuperKeyHUB-VERSION-macOS.zip`
          
          ## 更新记录
          
          ## 注意事项
          - Windows 版本需要管理员权限以获取完整硬件信息
          - macOS 版本在 Apple Silicon 和 Intel Mac 上均可运行
          EOF
          
          # 替换版本号
          sed -i "s/VERSION/$VERSION/g" release_notes.md
          
          echo "[OK] Release notes generated"
          cat release_notes.md

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.check-release.outputs.app_version }}
          name: Release v${{ needs.check-release.outputs.app_version }}
          body_path: release_notes.md
          files: artifacts/*
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(needs.check-release.outputs.app_version, '-alpha') || contains(needs.check-release.outputs.app_version, '-beta') || contains(needs.check-release.outputs.app_version, '-rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}